/*
 * Sibilla:  a Java framework designed to support analysis of Collective
 * Adaptive Systems.
 *
 *             Copyright (C) 2020.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *            http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package it.unicam.quasylab.sibilla.langs.lio;


import it.unicam.quasylab.sibilla.langs.util.ErrorCollector;
import it.unicam.quasylab.sibilla.langs.util.ParseError;
import org.antlr.v4.runtime.Token;

import java.util.Map;
import java.util.stream.Collectors;

/**
 * This class is used to validate the parse tree generated by a parser.
 */
public class LIOModelValidator extends LIOModelBaseVisitor<Boolean> {

    private final SymbolTable table;
    private final ErrorCollector errors;

    private final AgentRegistry registry;

    public LIOModelValidator(ErrorCollector errors) {
        this.errors = errors;
        this.table = new SymbolTable();
        this.registry = new AgentRegistry();
    }


    @Override
    public Boolean visitModel(LIOModelParser.ModelContext ctx) {
        if (ctx.accept(new SymbolCollector())) {
            boolean result = true;
            for (LIOModelParser.ElementContext e: ctx.modelContent) {
                result &= e.accept(this);
            }
            return result;
        } else {
            return false;
        }
    }

    private synchronized void recordError(String message, int line, int charPositionInLine) {
        this.errors.record(new ParseError(message, line, charPositionInLine));
    }

    @Override
    public Boolean visitElementParam(LIOModelParser.ElementParamContext ctx) {
        if (TypeInferenceVisitor.hasType(table, errors, LIOType.LIO_REAL, ctx.value)) {
            table.recordType(ctx.name.getText(), LIOType.LIO_REAL);
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Boolean visitElementConstant(LIOModelParser.ElementConstantContext ctx) {
        LIOType type = TypeInferenceVisitor.inferTypeOf(table, errors, ctx.value);
        if (LIOType.LIO_NONE != type) {
            table.recordType(ctx.name.getText(), type);
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Boolean visitElementAction(LIOModelParser.ElementActionContext ctx) {
        return TypeInferenceVisitor.hasType(table, errors, LIOType.LIO_MEASURE, ctx.probability);
    }

    @Override
    public Boolean visitAgentStep(LIOModelParser.AgentStepContext ctx) {
        boolean result = true;
        if (!table.isAction(ctx.performedAction.getText())) {
            recordError(ParseUtil.unknownActionError(ctx.performedAction),ctx.performedAction.getLine(), ctx.performedAction.getCharPositionInLine());
            result = false;
        }
        if (!table.isState(ctx.nextState.getText())) {
            recordError(ParseUtil.unknownStateError(ctx.nextState),ctx.nextState.getLine(), ctx.nextState.getCharPositionInLine());
            result = false;
        }
        return result;
    }

    @Override
    public Boolean visitElementState(LIOModelParser.ElementStateContext ctx) {
        boolean result = true;
        for (LIOModelParser.AgentStepContext step: ctx.agentStep()) {
            result &= step.accept(this);
        }
        return result;
    }

    @Override
    public Boolean visitElementMeasure(LIOModelParser.ElementMeasureContext ctx) {
        return TypeInferenceVisitor.hasType(table, errors, LIOType.LIO_MEASURE, ctx.value);
    }

    @Override
    public Boolean visitElementAtomic(LIOModelParser.ElementAtomicContext ctx) {
        boolean result = true;
        //FIXME!
//        for (Token state: ctx.states) {
//            if (!table.isState(state.getText())) {
//                recordError(ParseUtil.unknownStateError(state),state.getLine(), state.getCharPositionInLine());
//                result = false;
//            }
//        }
        return result;
    }

    @Override
    public Boolean visitElementPredicate(LIOModelParser.ElementPredicateContext ctx) {
        return TypeInferenceVisitor.hasType(table, errors, LIOType.LIO_PREDICATE, ctx.value);
    }

    @Override
    public Boolean visitElementSystem(LIOModelParser.ElementSystemContext ctx) {
        Map<String, LIOType> localVariables = ctx.args.stream().collect(Collectors.toMap(Token::getText, t -> LIOType.LIO_INTEGER));
        boolean result = true;
        for (LIOModelParser.AgentExpressionContext agentExpression: ctx.agentExpression()) {
            if (!table.isState(agentExpression.name.getText())) {
                recordError(ParseUtil.unknownStateError(agentExpression.name),agentExpression.name.getLine(), agentExpression.name.getCharPositionInLine());
                result = false;
            }
            result &= (agentExpression.size == null)||(TypeInferenceVisitor.hasType(localVariables, table, errors, LIOType.LIO_REAL, agentExpression.size));
        }
        return result;
    }

    public SymbolTable getSymbolTable() {
        return this.table;
    }

    public class SymbolCollector extends LIOModelBaseVisitor<Boolean> {


        @Override
        public Boolean visitModel(LIOModelParser.ModelContext ctx) {
            boolean result = true;
            for (LIOModelParser.ElementContext e: ctx.modelContent) {
                result &= e.accept(this);
            }
            return result;
        }

        @Override
        public Boolean visitElementParam(LIOModelParser.ElementParamContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addParameter(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementConstant(LIOModelParser.ElementConstantContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addConstant(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementAction(LIOModelParser.ElementActionContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addAction(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementState(LIOModelParser.ElementStateContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addState(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementMeasure(LIOModelParser.ElementMeasureContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addMeasure(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementAtomic(LIOModelParser.ElementAtomicContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addAtomic(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementSystem(LIOModelParser.ElementSystemContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addSystem(ctx);
                return true;
            }
        }

        @Override
        public Boolean visitElementPredicate(LIOModelParser.ElementPredicateContext ctx) {
            if (table.isDefined(ctx.name.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(ctx.name, table.getDeclarationToken(ctx.name.getText())),ctx.name.getLine(), ctx.name.getCharPositionInLine());
                return false;
            } else {
                table.addPredicate(ctx);
                return true;
            }
        }
    }



}

