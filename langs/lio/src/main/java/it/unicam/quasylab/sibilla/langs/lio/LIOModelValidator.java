/*
 * Sibilla:  a Java framework designed to support analysis of Collective
 * Adaptive Systems.
 *
 *             Copyright (C) 2020.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *            http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package it.unicam.quasylab.sibilla.langs.lio;


import it.unicam.quasylab.sibilla.core.models.lio.Agent;
import it.unicam.quasylab.sibilla.core.util.values.SibillaValue;
import it.unicam.quasylab.sibilla.langs.util.ErrorCollector;
import it.unicam.quasylab.sibilla.langs.util.ParseError;
import org.antlr.v4.runtime.Token;

import java.util.*;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

/**
 * This class is used to validate the parse tree generated by a parser.
 */
public class LIOModelValidator extends LIOModelParseTreeChecker {


    private final Map<String, Token> tokens = new HashMap<>();

    private final Map<String, LIOType[]> statesPrototype = new HashMap<>();

    private final Set<String> parameters = new HashSet<>();

    private final Map<String, LIOModelParser.ElementActionContext> actions = new HashMap<>();

    private final Map<String, LIOModelParser.ElementStateContext> states = new HashMap<>();

    private final Map<String, LIOModelParser.ElementMeasureContext> measures = new HashMap<>();

    private final Map<String, LIOType> typeMap = new HashMap<>();

    private final Map<String, LIOModelParser.ElementAtomicContext> atomics = new HashMap<>();
    private final Map<String, LIOModelParser.ElementSystemContext> systems = new HashMap<>();
    private final Map<String, LIOModelParser.ElementPredicateContext> predicates = new HashMap<>();


    public LIOModelValidator(ErrorCollector errors) {
        super(errors);
    }

    private boolean isDefined(String name) {
        return tokens.containsKey(name);
    }

    private Token getToken(String name) {
        return tokens.get(name);
    }

    private void addToken(String name, Token token) {
        tokens.put(name, token);
    }

    private void recordType(String name, LIOType type) {
        typeMap.put(name, type);
    }

    private boolean checkAndAdd(Token token) {
        if (isDefined(token.getText())) {
            recordError(ParseUtil.duplicatedNameErrorMessage(token, getToken(token.getText())),token.getLine(), token.getCharPositionInLine());
            return false;
        } else {
            addToken(token.getText(), token);
            return true;
        }

    }

    @Override
    public Boolean visitModel(LIOModelParser.ModelContext ctx) {
        return validateModel(ctx);
    }



    public boolean validateModel(LIOModelParser.ModelContext ctx) {
        ctx.accept(new SymbolCollector());
        actions.values().forEach(this::validateAction);
        states.values().forEach(this::validateState);
        measures.values().forEach(this::validateMeasure);
        predicates.values().forEach(this::validatePredicate);
        atomics.values().forEach(this::validateAtomic);
        systems.values().forEach(this::validateSystem);
        return errors.withErrors();
    }

    private void validateSystem(LIOModelParser.ElementSystemContext elementSystemContext) {
        checkDuplicatedParameters(elementSystemContext.args);
        elementSystemContext.population.accept(new PopulationExpressionValidator(elementSystemContext.args.stream().map(Token::getText).collect(Collectors.toMap(n -> n, n -> LIOType.LIO_INTEGER)), this.errors));
    }


    private void validateAtomic(LIOModelParser.ElementAtomicContext elementAtomicContext) {
        elementAtomicContext.states.forEach(this::validateAgentPattern);
    }

    private void validateAgentPattern(LIOModelParser.AgentPatternContext agentPatternContext) {
        checkStateArity(agentPatternContext.name, agentPatternContext.patternElements.size());
        if (agentPatternContext.guard != null) {
            Map<String, LIOType> localVariables = extractPatternVariables(agentPatternContext.patternElements);
            checkType(LIOType.LIO_BOOLEAN, new TypeInferenceVisitor(LIOTypeResolver.resolverOf(localVariables), errors), agentPatternContext.guard);
        }
    }

    private Map<String, LIOType> extractPatternVariables(List<LIOModelParser.PatternElementContext> patternElements) {
        Map<String, LIOType> result = new HashMap<>();
        for (LIOModelParser.PatternElementContext p: patternElements) {
            if (p instanceof LIOModelParser.PatternElementVariableContext) {
                result.put(((LIOModelParser.PatternElementVariableContext) p).name.getText(), LIOType.LIO_INTEGER);
            }
        }
        return result;
    }


    private void checkType(LIOType expected, TypeInferenceVisitor visitor, LIOModelParser.ExprContext ctx) {
        LIOType type = ctx.accept(visitor);
        if (!expected.compatibleWith(type)) {
            recordError(ParseUtil.typeErrorMessage(LIOType.LIO_REAL, type, ctx.start), ctx.start.getLine(), ctx.start.getCharPositionInLine());
        }
    }

    private void validatePredicate(LIOModelParser.ElementPredicateContext elementPredicateContext) {
        checkType(LIOType.LIO_BOOLEAN, new TypeInferenceVisitor(this.statesPrototype, LIOTypeResolver.resolverOf(typeMap), errors), elementPredicateContext.value);
    }

    private void validateMeasure(LIOModelParser.ElementMeasureContext elementMeasureContext) {
        checkType(LIOType.LIO_REAL, new TypeInferenceVisitor(this.statesPrototype, LIOTypeResolver.resolverOf(typeMap), errors), elementMeasureContext.value);
    }

    private void validateState(LIOModelParser.ElementStateContext elementStateContext) {
        checkDuplicatedParameters(elementStateContext.agentParameters.stream().map(p -> p.name).collect(Collectors.toList()));
        elementStateContext.agentParameters.forEach(this::validateStateParameter);
        Map<String, LIOType> localParameters = elementStateContext.
                agentParameters.stream().
                map(p -> p.name.getText()).collect(Collectors.toMap(n -> n, n -> LIOType.LIO_INTEGER));
        elementStateContext.steps.forEach(as -> validateAgentStep(localParameters, as));
    }

    private void validateAgentStep(Map<String, LIOType> localParameters, LIOModelParser.AgentStepContext agentStepContext) {
        if (agentStepContext.guard != null) {
            checkType(LIOType.LIO_BOOLEAN, new TypeInferenceVisitor(LIOTypeResolver.resolverOf(localParameters), errors), agentStepContext.guard);
        }
        checkAgentPrototype(localParameters, agentStepContext.nextState, agentStepContext.stateArguments);
    }

    private void checkAgentPrototype(Map<String, LIOType> localParameters, Token nextState, List<LIOModelParser.ExprContext> stateArguments) {
        checkStateArity(nextState, stateArguments.size());
        LIOTypeResolver resolver = LIOTypeResolver.resolverOf(localParameters).orElse(LIOTypeResolver.resolverOf(typeMap));
        stateArguments.forEach(exp -> checkInteger(resolver, exp));
    }

    private boolean checkStateArity(Token nextState, int arity) {
        if (!this.statesPrototype.containsKey(nextState.getText())) {
            recordError(ParseUtil.unknownStateError(nextState), nextState.getLine(), nextState.getCharPositionInLine());
            return false;
        }
        int args = this.statesPrototype.get(nextState.getText()).length;
        if (args != arity) {
            recordError(ParseUtil.wrongNumberOfAgentParameters(nextState, args, arity), nextState.getLine(), nextState.getCharPositionInLine());
            return false;
        }
        return true;
    }

    private boolean checkInteger(LIOTypeResolver resolver, LIOModelParser.ExprContext exp) {
        return checkType(resolver, LIOType.LIO_INTEGER, exp);
    }

    private boolean checkBoolean(LIOTypeResolver resolver, LIOModelParser.ExprContext exp) {
        return checkType(resolver, LIOType.LIO_BOOLEAN, exp);
    }

    private boolean checkType(LIOTypeResolver resolver, LIOType expected, LIOModelParser.ExprContext exp) {
        LIOType type = exp.accept(new TypeInferenceVisitor(resolver, errors));
        if (!expected.compatibleWith(type)) {
            recordError(ParseUtil.typeErrorMessage(expected, type, exp.start), exp.start.getLine(), exp.start.getCharPositionInLine());
            return false;
        } else {
            return true;
        }
    }


    private void checkDuplicatedParameters(List<Token> parameters) {
        Map<String, Token> alreadyDeclared = new HashMap<>();
        for (Token token: parameters) {
            if (alreadyDeclared.containsKey(token.getText())) {
                recordError(ParseUtil.duplicatedNameErrorMessage(token, alreadyDeclared.get(token.getText())), token.getLine(), token.getCharPositionInLine());
            } else {
                alreadyDeclared.put(token.getText(), token);
            }
        }
    }

    private void validateStateParameter(LIOModelParser.AgentParameterDeclarationContext agentParameterDeclarationContext) {
        checkInteger(agentParameterDeclarationContext.from);
        checkInteger(agentParameterDeclarationContext.to);
    }

    private void checkInteger(LIOModelParser.ExprContext expr) {
        checkInteger(LIOTypeResolver.resolverOf(typeMap), expr);
    }


    private void validateAction(LIOModelParser.ElementActionContext value) {
        checkType(LIOType.LIO_REAL, new TypeInferenceVisitor(this.statesPrototype, LIOTypeResolver.resolverOf(this.typeMap), errors), value.probability);
    }

    private synchronized void recordError(String message, int line, int charPositionInLine) {
        this.errors.record(new ParseError(message, line, charPositionInLine));
    }



    public class SymbolCollector extends LIOModelBaseVisitor<Boolean> {


        @Override
        public Boolean visitModel(LIOModelParser.ModelContext ctx) {
            boolean result = true;
            for (LIOModelParser.ElementContext e: ctx.modelContent) {
                result &= e.accept(this);
            }
            return result;
        }

        @Override
        public Boolean visitElementParam(LIOModelParser.ElementParamContext ctx) {
            return handleConstantsAndParams(ctx.name, ctx.value, true);
        }

        private Boolean handleConstantsAndParams(Token token, LIOModelParser.ExprContext expr, boolean isParameter) {
            String name = token.getText();
            if (checkAndAdd(token)) {
                TypeInferenceVisitor visitor = new TypeInferenceVisitor(statesPrototype, LIOTypeResolver.resolverOf(typeMap), errors, false);
                LIOType type = expr.accept(visitor);
                if (!visitor.withError()) {
                    recordType(name, type);
                    if (isParameter) parameters.add(token.getText());
                }
                return true;
            } else {
                return false;
            }
        }

        @Override
        public Boolean visitElementConstant(LIOModelParser.ElementConstantContext ctx) {
            return handleConstantsAndParams(ctx.name, ctx.value, false);
        }

        @Override
        public Boolean visitElementAction(LIOModelParser.ElementActionContext ctx) {
            if (checkAndAdd(ctx.name)) {
                addToken(ctx.name.getText(), ctx.name);
                actions.put(ctx.name.getText(), ctx);
                return true;
            } else {
                return false;
            }
        }

        @Override
        public Boolean visitElementState(LIOModelParser.ElementStateContext ctx) {
            if (checkAndAdd(ctx.name)) {
                addToken(ctx.name.getText(), ctx.name);
                states.put(ctx.name.getText(), ctx);
                LIOType[] type = new LIOType[ctx.agentParameters.size()];
                Arrays.fill(type, LIOType.LIO_INTEGER);
                statesPrototype.put(ctx.name.getText(), type);
                return true;
            } else {
                return false;
            }
        }

        @Override
        public Boolean visitElementMeasure(LIOModelParser.ElementMeasureContext ctx) {
            if (checkAndAdd(ctx.name)) {
                addToken(ctx.name.getText(), ctx.name);
                measures.put(ctx.name.getText(), ctx);
                return true;
            } else {
                return false;
            }
        }

        @Override
        public Boolean visitElementAtomic(LIOModelParser.ElementAtomicContext ctx) {
            if (checkAndAdd(ctx.name)) {
                addToken(ctx.name.getText(), ctx.name);
                atomics.put(ctx.name.getText(), ctx);
                return true;
            } else {
                return false;
            }
        }

        @Override
        public Boolean visitElementSystem(LIOModelParser.ElementSystemContext ctx) {
            if (checkAndAdd(ctx.name)) {
                systems.put(ctx.name.getText(), ctx);
                return true;
            } else {
                return false;
            }
        }

        @Override
        public Boolean visitElementPredicate(LIOModelParser.ElementPredicateContext ctx) {
            if (checkAndAdd(ctx.name)) {
                predicates.put(ctx.name.getText(), ctx);
                return true;
            } else {
                return false;
            }
        }
    }


    public class PopulationExpressionValidator extends LIOModelParseTreeChecker {

        private final Map<String, LIOType> arguments;

        /**
         * Creates a new instance that stores errors in the given collector.
         *
         * @param errors the collector used to store errors.
         */
        public PopulationExpressionValidator(Map<String, LIOType> arguments, ErrorCollector errors) {
            super(errors);
            this.arguments = arguments;
        }

        @Override
        public Boolean visitPopulationExpressionFor(LIOModelParser.PopulationExpressionForContext ctx) {
            LIOType old = arguments.put(ctx.name.getText(), LIOType.LIO_INTEGER);
            LIOTypeResolver resolver = LIOTypeResolver.resolverOf(arguments).orElse(LIOTypeResolver.resolverOf(typeMap));
            boolean flag = checkInteger(resolver, ctx.from)
                    &checkInteger(resolver, ctx.to)
                    &ctx.body.accept(this);
            if (old != null) {
                arguments.put(ctx.name.getText(), old);
            }
            return flag;
        }

        @Override
        public Boolean visitPopulationExpressionIfThenElse(LIOModelParser.PopulationExpressionIfThenElseContext ctx) {
            return checkBoolean(LIOTypeResolver.resolverOf(arguments), ctx.guard)
                    & ctx.thenPopulation.accept(this)
                    & ctx.elsePopulation.accept(this);
        }

        @Override
        public Boolean visitPopulationExpressionParallel(LIOModelParser.PopulationExpressionParallelContext ctx) {
            return ctx.left.accept(this)&ctx.right.accept(this);
        }

        @Override
        public Boolean visitPopulationExpressionAgent(LIOModelParser.PopulationExpressionAgentContext ctx) {
            return checkStateArity(ctx.name, ctx.stateArguments.size())
                    & ctx.stateArguments.stream().allMatch(expr -> checkInteger(LIOTypeResolver.resolverOf(arguments), expr))
                    & (ctx.size == null || checkInteger(LIOTypeResolver.resolverOf(arguments), ctx.size));
        }
    }

}

