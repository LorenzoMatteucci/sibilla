/*
 * Sibilla:  a Java framework designed to support analysis of Collective
 * Adaptive Systems.
 *
 *             Copyright (C) 2020.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *            http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package it.unicam.quasylab.sibilla.core.models.slam.agents;

import it.unicam.quasylab.sibilla.core.models.slam.*;
import it.unicam.quasylab.sibilla.core.models.slam.data.AgentStore;
import it.unicam.quasylab.sibilla.core.models.slam.data.AgentVariable;
import it.unicam.quasylab.sibilla.core.util.datastructures.Pair;
import it.unicam.quasylab.sibilla.core.util.values.SibillaValue;
import org.apache.commons.math3.random.RandomGenerator;

import java.util.LinkedList;
import java.util.List;
import java.util.function.*;

/**
 * This functional interface is used to represent a command executed by an action. This is a function that, given
 * an agent memory returns the list of messages that are generated by the command. During the execution, the
 * memory passed as an argument can be changed.
 *
 */
@FunctionalInterface
public interface SlamAgentCommand {

    /**
     * Executes an agent command and returns the list of messages sent by the agent.
     *
     * @param rg random generator used to sample random values.
     * @param memory agent memory where the command is executed.
     * @return the list of messages sent by the agent during the execution.
     */
    Pair<List<OutgoingMessage>, List<Pair<AgentVariable, SibillaValue>>> execute(RandomGenerator rg, AgentStore memory);

    /**
     * Returns an agent command that sequentially exectues each of the commands received as arguments and returns
     * the concatenation of the messages sent by each of the executed command.
     * @param commands arrays of commands to execute.
     * @return the list of messages sent by the agent during the execution.
     */
    static SlamAgentCommand combine(SlamAgentCommand... commands) {
        return (rg, m) ->  {
            LinkedList<OutgoingMessage> messages = new LinkedList<>();
            LinkedList<Pair<AgentVariable, SibillaValue>> assignments = new LinkedList<>();
            for (SlamAgentCommand c: commands) {
                Pair<List<OutgoingMessage>, List<Pair<AgentVariable, SibillaValue>>> result = c.execute(rg, m);
                messages.addAll(result.getKey());
                assignments.addAll(result.getValue());
            }
            return Pair.of(messages, assignments);
        };
    }

    /**
     * Returns a command that randomly executes one of the command received as arguments.
     *
     * @param options a list of pairs each of which contains the function used to compute the probability to select a
     *                command and the command to execute.
     * @return a command that randomly selects one of the given options.
     */
    static SlamAgentCommand select(List<Pair<ToDoubleBiFunction<RandomGenerator, AgentStore>,SlamAgentCommand>> options) {
        return (rg, m) -> {
            SlamAgentCommand selected = Util.select(rg, m, options);
            if (selected != null) {
                return selected.execute(rg, m);
            } else {
                return Pair.of(List.of(), List.of());
            }
        };
    }

    /**
     * Returns a command that tests the given condition and if this is true <code>thenCommand</code> is executed,
     * otherwise <code>elseCommand</code> is executed.
     *
     * @param condition a predicate on received memory.
     * @param thenCommand command that is executed if the condition is true.
     * @param elseCommand command that is executed if the condition is false.
     * @return the list of messages sent by the agent during the execution.
     */
    static SlamAgentCommand ifThenElse(BiFunction<RandomGenerator, AgentStore, SibillaValue> condition, SlamAgentCommand thenCommand, SlamAgentCommand elseCommand ) {
        return (rg, m) -> {
            if (condition.apply(rg, m).booleanOf()) {
                return thenCommand.execute(rg, m);
            } else {
                return elseCommand.execute(rg, m);
            }
        };
    }

    /**
     * Returns a command that tests the given condition and if this is true <code>thenCommand</code> is executed,
     * otherwise no action is preformed.
     *
     * @param condition a predicate on received memory.
     * @param thenCommand command that is executed if the condition is true.
     * @return the list of messages sent by the agent during the execution.
     */
    static SlamAgentCommand ifCommand(BiFunction<RandomGenerator, AgentStore, SibillaValue> condition, SlamAgentCommand thenCommand) {
        return ifThenElse(condition, thenCommand, SKIP);
    }

    /**
     * Is an agent command that does not execute any update on the memory and that does not
     * send any message.
     */
    SlamAgentCommand SKIP  = (rg, m) -> Pair.of(List.of(), List.of());

    /**
     * Returns an agent command that updates the given memory by setting the given variable
     * to the result of the evaluation of <code>expr</code>.
     *
     * @param var variable to set.
     * @param expr epression.
     * @return an empty list.
     */
    static SlamAgentCommand setCommand(AgentVariable var, BiFunction<RandomGenerator, AgentStore, SibillaValue> expr) {
        return (rg, m) -> Pair.of(List.of(), List.of(Pair.of(var, expr.apply(rg,m))));
    }

    /**
     * Returns an agent command that sends a single message obtained from the evaluation of the given function.
     *
     * @param message the expression used to obtain the message to send.
     * @return the list containing the single sent message.
     */
    static SlamAgentCommand send(BiFunction<RandomGenerator, AgentStore, AgentMessage> message, ToDoubleBiFunction<RandomGenerator, AgentStore> deliveryTime) {
        return (rg, m) -> Pair.of(List.of(new OutgoingMessage(message.apply(rg,m), deliveryTime)), List.of());
    }

    static SlamAgentCommand letIn(AgentVariable variable, BiFunction<RandomGenerator, AgentStore, SibillaValue> expr, SlamAgentCommand command) {
        return (rg, m) -> command.execute(rg, m.set(variable, expr.apply(rg, m)));
    }
}
