/*
 * Sibilla:  a Java framework designed to support analysis of Collective
 * Adaptive Systems.
 *
 *             Copyright (C) 2020.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *            http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package it.unicam.quasylab.sibilla.core.models.slam.agents;

import it.unicam.quasylab.sibilla.core.models.slam.*;
import it.unicam.quasylab.sibilla.core.models.slam.data.AgentStore;
import it.unicam.quasylab.sibilla.core.models.slam.data.AgentVariable;
import it.unicam.quasylab.sibilla.core.models.slam.data.SlamValue;
import org.apache.commons.math3.random.RandomGenerator;

import java.util.LinkedList;
import java.util.List;
import java.util.function.*;

/**
 * This functional interface is used to represent a command executed by an action. This is a function that, given
 * an agent memory returns the list of messages that are generated by the command. During the execution, the
 * memory passed as an argument can be changed.
 *
 */
@FunctionalInterface
public interface AgentCommand {

    /**
     * Executes an agent command and returns the list of messages sent by the agent.
     *
     * @param rg random generator used to sample random values.
     * @param evaluator object used to evaluate expressions at global level.
     * @param memory agent memory where the command is executed.
     * @return the list of messages sent by the agent during the execution.
     */
    List<AgentMessage> execute(RandomGenerator rg, StateExpressionEvaluator evaluator, AgentStore memory);

    /**
     * Returns an agent command that sequentially exectues each of the commands received as arguments and returns
     * the concatenation of the messages sent by each of the executed command.
     * @param commands arrays of commands to execute.
     * @return the list of messages sent by the agent during the execution.
     */
    static AgentCommand combine(AgentCommand ... commands) {
        return (rg, evaluator, m) ->  {
            LinkedList<AgentMessage> messages = new LinkedList<>();
            for (AgentCommand c: commands) {
                messages.addAll(c.execute(rg, evaluator, m));
            }
            return messages;
        };
    }

    /**
     * Returns a command that randomly executes one of the command received as arguments. The command to be
     * executed is selected according to the weights passed as the first argument.
     *
     * @param weights weights associated with each command.
     * @param options the array of commands to execute.
     * @return the list of messages sent by the agent during the execution.
     */
    static AgentCommand select(ToDoubleBiFunction<RandomGenerator, AgentStore>[] weights, AgentCommand[] options) {
        if (weights.length != options.length) {
            throw new IllegalArgumentException();//TODO: Add Message!
        }
        return (rg, evaluator, m) -> {
            AgentCommand selected = Util.select(rg, m, weights, options);
            if (selected != null) {
                return selected.execute(rg, evaluator, m);
            } else {
                return List.of();
            }
        };
    }

    /**
     * Returns a command that tests the given condition and if this is true <code>thenCommand</code> is executed,
     * otherwise <code>elseCommand</code> is executed.
     *
     * @param condition a predicate on received memory.
     * @param thenCommand command that is executed if the condition is true.
     * @param elseCommand command that is executed if the condition is false.
     * @return the list of messages sent by the agent during the execution.
     */
    static AgentCommand ifThenElse(Predicate<AgentStore> condition, AgentCommand thenCommand, AgentCommand elseCommand ) {
        return (rg, evaluator, m) -> {
            if (condition.test(m)) {
                return thenCommand.execute(rg, evaluator, m);
            } else {
                return elseCommand.execute(rg, evaluator, m);
            }
        };
    }

    /**
     * Returns a command that tests the given condition and if this is true <code>thenCommand</code> is executed,
     * otherwise no action is preformed.
     *
     * @param condition a predicate on received memory.
     * @param thenCommand command that is executed if the condition is true.
     * @return the list of messages sent by the agent during the execution.
     */
    static AgentCommand ifCommand(Predicate<AgentStore> condition, AgentCommand thenCommand) {
        return ifThenElse(condition, thenCommand, SKIP);
    }

    /**
     * Is an agent command that does not execute any update on the memory and that does not
     * send any message.
     */
    AgentCommand SKIP  = (rg, evaluator, m) -> List.of();

    /**
     * Returns an agent command that updates the given memory by setting the given variable
     * to the result of the evaluation of <code>expr</code>.
     *
     * @param var variable to set.
     * @param expr epression.
     * @return an empty list.
     */
    static AgentCommand setCommand(AgentVariable var, BiFunction<RandomGenerator, AgentStore, SlamValue> expr) {
        return (rg, evaluator, m) -> {
            m.set(var, expr.apply(rg,m));
            return List.of();
        };
    }

    /**
     * Returns an agent command that sends a single message obtained from the evaluation of the given function.
     *
     * @param message the expression used to obtain the message to send.
     * @return the list containing the single sent message.
     */
    static AgentCommand send(BiFunction<RandomGenerator, AgentStore, AgentMessage> message) {
        return (rg, evaluator, m) -> List.of(message.apply(rg,m));
    }
}
